package minows

import (
	"regexp"
	"strings"

	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/protocol"
	ma "github.com/multiformats/go-multiaddr"
	"go.dedis.ch/dela/mino"
	"go.dedis.ch/dela/serde"
	"golang.org/x/xerrors"
)

// Minows implements mino.Mino
type Minows struct {
	myAddr     Address
	segments   []string
	host       host.Host
	rpcsByName map[string]RPC
}

// NewMinows
// listen: local listening address in multiaddress format, e.g. /ip4/0.0.0.0/tcp/80
// public: public dial-able address in multiaddress format, e.g. /dns4/p2p-1.c4dt.dela.org/tcp/443/wss
// pid: Peer ID (multi-hash of public key generated by libp2p)
func NewMinows(listen, public, pid string) (*Minows, error) {
	_, err := ma.NewMultiaddr(listen)
	if err != nil {
		return nil, xerrors.Errorf("could not parse listen addr: %v", err)
	}
	myAddr, err := NewAddress(public, pid)
	if err != nil {
		return nil, xerrors.Errorf("could not create address: %v", err)
	}
	// TODO read key pair as identity
	// TODO create host & start listening
	return &Minows{
		myAddr:   myAddr,
		segments: nil,
	}, nil
}

func (m *Minows) GetAddressFactory() mino.AddressFactory {
	return addressFactory{}
}

func (m *Minows) GetAddress() mino.Address {
	return m.myAddr
}

func (m *Minows) WithSegment(segment string) mino.Mino {
	if segment == "" {
		return m
	}

	return &Minows{
		myAddr:   m.myAddr,
		segments: append(m.segments, segment),
	}
}

func (m *Minows) CreateRPC(name string, h mino.Handler, f serde.Factory) (mino.RPC, error) {
	pattern := regexp.MustCompile("^[a-zA-Z0-9]+$")
	// validate segments
	if len(m.rpcsByName) == 0 { // no RPC created yet
		for _, seg := range m.segments {
			if !pattern.MatchString(seg) {
				return nil, xerrors.Errorf("invalid segment: %s", seg)
			}
		}
	}
	// validate name
	if !pattern.MatchString(name) {
		return nil, xerrors.Errorf("invalid name: %s", name)
	}
	if _, ok := m.rpcsByName[name]; ok {
		return nil, xerrors.Errorf("already exists rpc: %s", name)
	}
	uri := strings.Join(append(m.segments, name), "/")
	pid := protocol.ID(uri)
	// TODO wrap mino.Handler in network.StreamHandler
	// m.host.SetStreamHandler(pid, h)
	return RPC{
		pid: pid,
	}, nil
}
